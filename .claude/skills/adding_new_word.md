# Skill: Adding New Words

## When to Use

When the user asks to add one or more Serbian words to the vocabulary. Words may come from a list, a file (e.g., `docs/useful_words.md`), or direct input.

## Prerequisites

- The app must be running or at least compilable (`mix compile` succeeds)
- Database is seeded and migrated

## Inputs

The user provides one or more words. For each word you need at minimum:
- `term` — the Serbian word (Latin script, with diacritics: č, ć, š, ž, đ)
- `translation` — English translation
- `part_of_speech` — one of: noun, verb, adjective, adverb, pronoun, numeral, preposition, conjunction, interjection, particle
- POS-specific fields (see Word Schema Fields below)

## Flow: For Each Word

### Step 0 — Validate Input Form

Check if the provided `term` is in its dictionary citation form (infinitive for verbs, nominative singular for nouns/adjectives, etc.).

- **If YES:** Proceed to Step 1.
- **If NO:** Do NOT proceed. Add the word to `docs/new_words_to_check.md` with the reason "Not in dictionary form" (see format in Step 3B) and move to the next word.

### Step 1 — LLM Generates All Forms

You (the LLM) generate every inflected form for the word based on its part of speech. Use your knowledge of Serbian grammar. Output a list of `{form, form_tag}` tuples.

**Expected form tags by POS:**

- **Nouns** (14 forms): `nom_sg`, `gen_sg`, `dat_sg`, `acc_sg`, `voc_sg`, `ins_sg`, `loc_sg`, `nom_pl`, `gen_pl`, `dat_pl`, `acc_pl`, `voc_pl`, `ins_pl`, `loc_pl`
- **Verbs** (24 forms): `infinitive`, `pres_1sg`, `pres_2sg`, `pres_3sg`, `pres_1pl`, `pres_2pl`, `pres_3pl`, `past_m_sg`, `past_f_sg`, `past_n_sg`, `past_m_pl`, `past_f_pl`, `past_n_pl`, `imp_2sg`, `imp_1pl`, `imp_2pl`, `pp_m_sg`, `pp_f_sg`, `pp_n_sg`, `pp_m_pl`, `pp_f_pl`, `pp_n_pl`, `pres_adv_participle`, `past_adv_participle`
- **Adjectives** (up to 84 forms): indefinite + definite × 7 cases × 2 numbers × 3 genders. Tags follow pattern: `indef_nom_sg_m`, `def_gen_pl_f`, etc.
- **Invariables** (adverb, preposition, conjunction, interjection, particle): `invariable` (plus optional `comparative`, `superlative` for adverbs)
- **Pronouns**: various `_sg`/`_pl` suffixed tags (paradigm-dependent)
- **Numerals**: ordinals get adjective-like forms; cardinals 5+ get single `base` form

### Step 2 — Validate LLM Forms Against Engine

Build the seed entry map (with the `"forms"` key containing your LLM-generated forms from Step 1) and run it through the Validator:

```elixir
entry = %{
  "term" => "kuća",
  "translation" => "house",
  "part_of_speech" => "noun",
  "gender" => "feminine",
  "declension_class" => "a_stem",
  "animate" => false,
  "grammar_metadata" => %{},
  "forms" => [
    %{"term" => "kuća", "form_tag" => "nom_sg"},
    %{"term" => "kuće", "form_tag" => "gen_sg"},
    # ... all LLM-generated forms
  ]
}

result = Ohmyword.Linguistics.Validator.validate(entry)
IO.puts(Ohmyword.Linguistics.Validator.format_result(result))
```

The Validator builds a Word struct, runs the engine, and compares every form tag. It reports:
- **MISSING**: form tags in your LLM forms but not generated by the engine
- **WRONG**: both sides have the tag but the term differs
- **EXTRA** (info only): engine generates tags not in your LLM forms

### Step 3 — All Forms Pass

`result.passed == true` means: the engine produced all expected form tags AND every form string matches the LLM's form string (case-insensitive, diacritics-sensitive comparison).

**Action: Add the word to `priv/repo/vocabulary_seed.json`**

Build the seed entry including the engine-generated forms (which matched the LLM forms). Including forms enables automated bulk validation later via the `validate_existing_words` skill.

```json
{
  "term": "kuća",
  "translation": "house",
  "categories": ["home"],
  "part_of_speech": "noun",
  "gender": "feminine",
  "declension_class": "a_stem",
  "animate": false,
  "proficiency_level": 1,
  "grammar_metadata": {},
  "forms": [
    {"form_tag": "nom_sg", "term": "kuća"},
    {"form_tag": "gen_sg", "term": "kuće"},
    {"form_tag": "dat_sg", "term": "kući"},
    {"form_tag": "acc_sg", "term": "kuću"},
    {"form_tag": "voc_sg", "term": "kućo"},
    {"form_tag": "ins_sg", "term": "kućom"},
    {"form_tag": "loc_sg", "term": "kući"},
    {"form_tag": "nom_pl", "term": "kuće"},
    {"form_tag": "gen_pl", "term": "kuća"},
    {"form_tag": "dat_pl", "term": "kućama"},
    {"form_tag": "acc_pl", "term": "kuće"},
    {"form_tag": "voc_pl", "term": "kuće"},
    {"form_tag": "ins_pl", "term": "kućama"},
    {"form_tag": "loc_pl", "term": "kućama"}
  ]
}
```

Then import the word into the database so it becomes searchable immediately (with locked seed forms):

```elixir
# In IEx or via mix run — use the same map you added to the seed JSON:
entry = %{
  "term" => "kuća",
  "translation" => "house",
  "part_of_speech" => "noun",
  "gender" => "feminine",
  "declension_class" => "a_stem",
  "animate" => false,
  "proficiency_level" => 1,
  "grammar_metadata" => %{},
  "categories" => ["home"],
  "forms" => [
    %{"form_tag" => "nom_sg", "term" => "kuća"},
    %{"form_tag" => "gen_sg", "term" => "kuće"}
    # ... all forms from the seed entry
  ]
}
{:ok, word} = Ohmyword.Vocabulary.WordImporter.import_from_seed(entry)
# This creates the Word record, inserts all seed forms as locked search terms,
# and runs the engine to fill any gaps (engine forms are unlocked).
```

**Why dual-form search storage:**
The `search_terms` table stores each inflected form twice: `term` (ASCII, e.g., "kuca") for case/diacritics-insensitive lookup, and `display_form` (diacritical, e.g., "kuća") for displaying the matched form to the user. When a user searches for "kuca", "kuća", or even "куча" (Cyrillic), the query is normalized to ASCII Latin and matched against `term`, but the result shows the proper `display_form`. This means every inflected form of every word is independently searchable.

### Step 3B — Failure Case (Mismatch or Missing Forms)

If `result.passed == false`:

**Action: Append to `docs/new_words_to_check.md`**

Use this format, appending to the file (create it if it doesn't exist). Include the Validator output:

```markdown
## kuća (noun, feminine)

**Validator output:**
kuća (noun): FAIL
  MISSING: voc_sg=kućo
  WRONG: gen_pl: expected 'kuća', got 'kućā'
  EXTRA (info): loc_pl=kućama
```

Do NOT add this word to the seed file. Move to the next word.

### Step 4 — Next Word

Repeat from Step 1 for the next word in the list.

## Word Schema Fields Reference

Required fields vary by `part_of_speech`:

| Field | Required For | Values |
|---|---|---|
| `term` | all | Serbian Latin with diacritics |
| `translation` | all | English |
| `part_of_speech` | all | noun, verb, adjective, adverb, pronoun, numeral, preposition, conjunction, interjection, particle |
| `proficiency_level` | all | 1-9 |
| `gender` | noun, adjective, pronoun | masculine, feminine, neuter |
| `animate` | masculine nouns | true/false (must be explicit) |
| `declension_class` | noun | consonant, a_stem, o_stem, e_stem, i_stem |
| `verb_aspect` | verb | imperfective, perfective, biaspectual |
| `conjugation_class` | verb | a_verb, i_verb, e_verb, je_verb, irregular |
| `reflexive` | verb | true/false |
| `transitive` | verb | true/false |
| `categories` | optional | array of strings |
| `grammar_metadata` | optional | JSON object for flags like `fleeting_a`, `soft_stem`, `extended_stem`, `present_stem`, `past_stem`, `irregular_forms`, `drops_in_plural`, `ins_ju`, `no_short_form` |

## Irregular Forms

If a word has irregular forms that the engine cannot derive from rules, add them to `grammar_metadata.irregular_forms`:

```json
{
  "grammar_metadata": {
    "irregular_forms": {
      "nom_pl": "ljudi",
      "gen_pl": "ljudi"
    }
  }
}
```

These are inserted as locked search terms (source: `:seed`) and the engine's `on_conflict: :nothing` respects them.

## Notes

- **Diacritics matter**: Always use proper Serbian Latin diacritics (č, ć, š, ž, đ). The engine produces diacritical forms. ASCII stripping happens only at the storage layer in CacheManager.
- **Adding words to DB**: Use `Ohmyword.Vocabulary.WordImporter.import_from_seed/1` in IEx to import a word with its locked seed forms. No need for `mix ecto.reset`.
- **Locked vs unlocked**: Manual/seed forms are `locked: true` and survive regeneration. Engine forms are `locked: false` and get wiped/recreated on regeneration.
- **Aspect pairs**: If adding a verb, check if its aspect pair already exists and link them via `aspect_pair_id` / `aspect_pair_term` in the seed JSON.
