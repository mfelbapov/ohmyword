# MASTER PROMPT: Serbian Language Learning App (Srpski)

> [!IMPORTANT]
> **Portfolio Note**: This document serves as the primary specification for the "Srpski" application. It demonstrates the ability to translate complex linguistic requirements into actionable technical specifications for AI-assisted development.

---

## 1. Project Context & Goals

**Objective**: Build a vocabulary learning application for English speakers learning Serbian, specifically addressing the grammatical complexities (cases, genders, aspects) that generic apps miss.

**Target Audience**: My son (primary), and other English speakers learning Serbian.

**Core Philosophy**: "Fake it till you automate it." Use a two-layer data architecture to separate linguistic correctness ("Source of Truth") from search performance ("Search Cache").

---

## 2. Architecture Strategy

### The "Two-Table" Approach

We separate the linguistic model from the access model.

1.  **`vocabulary_words` (Source of Truth)**
    *   Stores the "dictionary entry" or lemma.
    *   Contains deep linguistic metadata (gender, aspect pairs, etc.).
    *   Normalized.

2.  **`search_terms` (Search Cache)**
    *   Stores *every possible form* of a word (e.g., all 7 cases x 2 numbers = 14 forms for a noun).
    *   Maps directly to the `vocabulary_word_id`.
    *   Optimized for fast, fuzzy search.
    *   **Generation**: Initially populated manually or via simple scripts; eventually generated by a rule engine.

### Script Handling (Latin vs. Cyrillic)
*   **Database**: Store EVERYTHING in **Latin** script.
*   **UI**: Dynamically render Cyrillic using a robust transliteration utility.
*   **Input**: Allow users to type in either script; normalize to Latin for search.

---

## 3. Database Schema Specification

### Enums (Postgres)
Define these native enums for data integrity.

```sql
CREATE TYPE part_of_speech AS ENUM ('noun', 'verb', 'adjective', 'adverb', 'pronoun', 'preposition', 'conjunction', 'particle', 'numeral');
CREATE TYPE gender AS ENUM ('m', 'f', 'n'); -- Masculine, Feminine, Neuter
CREATE TYPE verb_aspect AS ENUM ('perfective', 'imperfective', 'bi_aspectual');
CREATE TYPE proficiency_level AS ENUM ('beginner', 'intermediate', 'advanced');
```

### Table: `vocabulary_words`

| Column | Type | Nullable | Notes |
| :--- | :--- | :--- | :--- |
| `id` | UUID | PK | |
| `term` | String | No | The headword (nominative singular or infinitive) |
| `translation` | String | No | Primary English translation |
| `translations` | Array[String] | No | defaults to `[]` |
| `part_of_speech` | part_of_speech | No | |
| `gender` | gender | Yes | Required for Nouns |
| `animate` | Boolean | Yes | Required for Masc. Nouns (affects Accusative) |
| `verb_aspect` | verb_aspect | Yes | Required for Verbs |
| `aspect_pair_id` | UUID | Yes | FK to `vocabulary_words` (self-ref) |
| `declension_class`| String | Yes | e.g., "type 1" (optional for now) |
| `usage_notes` | Text | Yes | Markdown supported |
| `categories` | Array[String] | No | defaults to `[]` |

### Table: `search_terms`

| Column | Type | Nullable | Notes |
| :--- | :--- | :--- | :--- |
| `term` | String | No | The declined/conjugated form (Latin) |
| `normalized_term`| String | No | Lowercase, stripped accents for search |
| `vocabulary_word_id` | UUID | No | FK |
| `form_description`| String | Yes | e.g., "Genitive Singular" |

---

## 4. Ecto Schema & Validation Rules

### `Srpski.Vocabulary.Word`
*   **Validations**:
    *   `term` and `translation` are required.
    *   If `part_of_speech` is `:noun`, `gender` is required.
    *   If `part_of_speech` is `:verb`, `verb_aspect` is required.
    *   `animate` defaults to `false`.

### `Srpski.Search.SearchTerm`
*   **Indexes**:
    *   `CREATE INDEX ... ON search_terms (normalized_term gin_trgm_ops)` (for fuzzy search).

---

## 5. Transliteration Utility (`Srpski.Utils.Transliteration`)

Implement a module with 1:1 mapping for Serbian Latin ↔ Cyrillic.

**Mapping Rules**:
*   A ↔ А
*   B ↔ Б
*   C ↔ Ц
*   Č ↔ Ч
*   Ć ↔ Ћ
*   Dž ↔ Џ (Digraph!)
*   Đ ↔ Ђ
*   E ↔ Е
*   F ↔ Ф
*   G ↔ Г
*   H ↔ Х
*   I ↔ И
*   J ↔ Ј
*   K ↔ К
*   L ↔ Л
*   Lj ↔ Љ (Digraph!)
*   M ↔ М
*   N ↔ Н
*   Nj ↔ Њ (Digraph!)
*   O ↔ О
*   P ↔ П
*   R ↔ Р
*   S ↔ С
*   Š ↔ Ш
*   T ↔ Т
*   U ↔ У
*   V ↔ В
*   Z ↔ З
*   Ž ↔ Ж

**Key Functions**:
*   `to_cyrillic(text)`: Converts Latin input to Cyrillic. *Handle digraphs (Lj, Nj, Dž) carefully—they must be converted before single letters.*
*   `to_latin(text)`: Converts Cyrillic input to Latin.

---

## 6. Seed Data Strategy

Create `priv/repo/seeds.exs` with a robust set of initial words to demonstrate the schema.

**Example Structure**:
```elixir
[
  %{
    term: "pas",
    translation: "dog",
    part_of_speech: :noun,
    gender: :m,
    animate: true,
    search_terms: [
      {"pas", "Nominative Sg"},
      {"psa", "Genitive Sg"},
      {"psu", "Dative Sg"},
      # ...
    ]
  },
  # ... more words
]
```

The seed script should insert the `Word`, then iterate over `search_terms` and insert them pointing to the Word.

---

## 7. Sprint Backlog

### Sprint 1: Foundation
- [x] Set up Phoenix with Tailwind
- [x] Define Database & Ecto Schemas
- [x] Implement Transliteration Utility
- [x] Seed ~50 common words with full declensions

### Sprint 2: Core UI
- [x] Flashcard LiveView (Random word)
- [x] Script Toggle (Latin/Cyrillic)
- [x] Search Interface (Find root from declined form)

### Sprint 3: Gamification (Upcoming)
- [ ] Spaced Repetition (SM-2 algorithm)
- [ ] Daily streaks
- [ ] Audio playback integration
