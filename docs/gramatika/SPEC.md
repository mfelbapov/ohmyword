# Serbian Language Learning App — Master Implementation Prompt (v2)

## 1. Project Context & Strategy

**Project**: Serbian Language Learning App (Elixir/Phoenix LiveView)
**Target Audience**: English speakers learning Serbian (specifically the developer's son)
**Current Phase**: Sprint 1 — Vocabulary Foundation
**App Name**: Decide on module prefix. This document uses `App` as placeholder. Replace with actual app name (e.g., `Srpski`, `SerbianApp`).

---

### Architecture Strategy: "Fake it till you Automate it"

The system uses a two-layer architecture separating linguistic truth from search performance:

| Layer | Table | Purpose |
|-------|-------|---------|
| **Source of Truth** | `vocabulary_words` | Stores root forms (nominative singular for nouns, infinitive for verbs) with full linguistic metadata. This is the "dictionary definition" and the fuel for the future rule engine. |
| **Read Cache** | `search_terms` | Flat denormalized table containing every searchable form (conjugations, declensions) mapped back to the root. Optimized for fast lookups. |

**Short-term approach**: The `search_terms` table is populated via a JSON seed file (AI-generated) containing pre-calculated forms. This ships immediately.

**Long-term approach**: An Elixir Rule Engine (in a `Linguistics` context) will derive forms programmatically from the `vocabulary_words` metadata, replacing the static seed.

**Script Strategy**: All data is stored in **Latin script**. Cyrillic is rendered dynamically in the UI via a transliteration utility. This keeps the database simple and searchable while supporting both scripts visually.

---

## 2. Database Schema Specification

### 2.A — PostgreSQL Enums (Strict Typing)

Create the following custom Postgres enum types. These enforce data integrity at the database level and provide clear documentation of valid values.

#### Enum: `part_of_speech`
```
noun, verb, adjective, adverb, pronoun, preposition, conjunction, interjection, particle, numeral
```

**Usage**: Mandatory for all vocabulary words. Determines which other fields are required/relevant.

#### Enum: `grammatical_gender`
```
masculine, feminine, neuter
```

**Usage**: Required for nouns, adjectives, pronouns, and some numerals. Nullable for other parts of speech.

#### Enum: `verb_aspect`
```
perfective, imperfective, biaspectual
```

**Usage**: Required for verbs. Serbian verbs fundamentally divide into these categories, affecting meaning and conjugation.

#### Enum: `search_term_source`
```
seed, manual, engine
```

**Usage**: Tracks provenance of search_terms entries for cache invalidation strategy.
- `seed` — Came from JSON seed file (AI-generated)
- `manual` — Human-corrected entry (protected from engine overwrites)
- `engine` — Generated by the future rule engine

---

### 2.B — Table: `vocabulary_words` (Source of Truth)

This is the canonical linguistic record for each vocabulary item. Think of it as the dictionary entry.

#### Identity Fields

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | `bigint` | PK, auto-increment | Standard primary key |
| `term` | `string` | NOT NULL, indexed | The dictionary form in Latin script. For nouns: nominative singular. For verbs: infinitive. For adjectives: masculine nominative singular indefinite. |
| `translation` | `string` | NOT NULL | Primary English meaning. Keep concise (1-3 words ideal). |
| `translations` | `array of strings` | Default `[]` | Alternative English meanings. Example: `["apartment", "flat", "dwelling"]` for "stan". |
| `part_of_speech` | `enum` | NOT NULL | Uses `part_of_speech` enum. |
| `proficiency_level` | `integer` | NOT NULL, Default 1 | Frequency-based difficulty tier. 1 = Top 100 most common words, 2 = Top 500, 3 = Top 1000, etc. Integer allows flexible expansion. |

#### Linguistic Fields — Nouns

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `gender` | `enum` | Required IF noun/adjective/pronoun | Uses `grammatical_gender` enum. |
| `animate` | `boolean` | Required IF masculine noun | **Critical for accusative case.** Animate masculine nouns use genitive form for accusative ("Vidim psa"). Inanimate use nominative ("Vidim sto"). Nullable for non-masculine or non-nouns. |
| `declension_class` | `string` | Recommended for nouns | Pattern classification for future rule engine. Values: `"a-stem"` (žena), `"o-stem"` (selo), `"e-stem"` (polje), `"consonant"` (pas, grad), `"i-stem"` (stvar). Nullable but aids automation. |

#### Linguistic Fields — Verbs

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `verb_aspect` | `enum` | Required IF verb | Uses `verb_aspect` enum. |
| `conjugation_class` | `string` | Recommended for verbs | Pattern classification. Values: `"a-verb"` (čitati), `"i-verb"` (govoriti), `"e-verb"` (pisati). Nullable but aids automation. |
| `reflexive` | `boolean` | Default `false` | True for reflexive verbs like "smejati se", "bojati se". The `term` field stores full form including "se". |
| `transitive` | `boolean` | Nullable | True = takes direct object, False = intransitive, Null = unknown/varies. Useful for advanced grammar features. |
| `aspect_pair_id` | `bigint` | FK to self, nullable | Links perfective/imperfective pairs. Example: "pisati" (impf) links to "napisati" (pf). Populate bidirectionally for easier queries. |

#### Linguistic Fields — Engine Configuration

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `grammar_metadata` | `jsonb` | Default `{}` | Flexible storage for exceptions, irregular forms, and rule engine configuration. See Section 3 for detailed schema by part of speech. |

#### Content & Media Fields

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `example_sentence_rs` | `text` | Nullable | Example sentence in Serbian (Latin script). |
| `example_sentence_en` | `text` | Nullable | English translation of example sentence. |
| `audio_url` | `string` | Nullable | URL to pronunciation audio file. |
| `image_url` | `string` | Nullable | URL to illustration/photo for visual learners. |
| `usage_notes` | `text` | Nullable | Free-form notes: register (formal/colloquial/vulgar), regional variations, common collocations, usage warnings. |

#### Categorization Fields

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `categories` | `array of strings` | Default `[]` | Semantic/thematic tags for lesson building. Examples: `["animals", "pets"]`, `["food", "vegetables"]`, `["travel", "transportation"]`. Future consideration: migrate to join table if hierarchy/descriptions needed. |

#### Timestamps

| Column | Type | Constraints |
|--------|------|-------------|
| `inserted_at` | `utc_datetime` | NOT NULL |
| `updated_at` | `utc_datetime` | NOT NULL |

#### Indexes

- Index on `term` (for direct lookups)
- Index on `part_of_speech` (for filtered queries)
- Index on `proficiency_level` (for difficulty-based queries)
- Index on `categories` using GIN (for array containment queries)

#### Uniqueness Strategy — Handling Homographs

Serbian has root-level homographs — different words with identical spelling:
- "kosa" (f) = hair
- "kosa" (f) = scythe
- "pas" (m) = dog
- "pas" (m) = belt (archaic)

**Design Decision**: The `term` column is **NOT unique**. Homographs are stored as separate rows with identical `term` values but different `translation`, `gender`, or other distinguishing fields.

**Implications**:
- Lookups may return multiple results — UI must handle this
- Seeds must include all homograph entries
- Consider adding a `sense_index` integer (default 1) if you need deterministic ordering of homographs

---

### 2.C — Table: `search_terms` (Read Cache)

A flat, denormalized table optimized for fast lookups. Contains every searchable surface form of every word.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | `bigint` | PK, auto-increment | Standard primary key |
| `term` | `string` | NOT NULL, indexed | The surface form in Latin script, **stored lowercase**. Examples: "psa", "psu", "psi" (forms of "pas"). |
| `form_tag` | `string` | NOT NULL | Grammatical description of this form. See Form Tag Conventions below. |
| `word_id` | `bigint` | FK to `vocabulary_words`, NOT NULL, ON DELETE CASCADE | Links back to the root word. Cascade ensures cache cleanup. |
| `source` | `enum` | NOT NULL, Default `seed` | Uses `search_term_source` enum. Tracks where this entry came from. |
| `locked` | `boolean` | NOT NULL, Default `false` | When true, the future rule engine will skip this row during regeneration. Use for manual corrections. |
| `inserted_at` | `utc_datetime` | NOT NULL | |
| `updated_at` | `utc_datetime` | NOT NULL | |

#### Cache Invalidation Strategy

The `source` and `locked` fields enable safe cache regeneration:

1. **Seed Phase (Sprint 1)**: All entries have `source: seed`, `locked: false`
2. **Manual Corrections**: When a human fixes an error, set `source: manual`, `locked: true`
3. **Engine Phase (Future)**: When regenerating cache:
   - DELETE all entries WHERE `locked = false`
   - INSERT new engine-generated entries with `source: engine`
   - Manual corrections are preserved

This prevents losing human corrections when the rule engine runs.

#### Indexes

- Index on `term` (primary lookup path)
- Unique composite index on `{term, word_id, form_tag}` — prevents duplicate entries from buggy seed scripts

#### Homograph Support

Multiple rows CAN have the same `term` value pointing to DIFFERENT `word_id` values. This is intentional and required.

Example: The form "stvar" might appear as:
- `{term: "stvar", form_tag: "nom_sg", word_id: 42}` (noun: thing)
- `{term: "stvar", form_tag: "nom_sg", word_id: 99}` (hypothetical homograph)

The search function must return ALL matches and let the UI/user disambiguate.

#### Form Tag Conventions

Use consistent, lowercase, underscore-separated tags:

**Nouns/Adjectives/Pronouns (Case + Number)**:
- `nom_sg`, `nom_pl` (nominative)
- `gen_sg`, `gen_pl` (genitive)
- `dat_sg`, `dat_pl` (dative)
- `acc_sg`, `acc_pl` (accusative)
- `voc_sg`, `voc_pl` (vocative)
- `ins_sg`, `ins_pl` (instrumental)
- `loc_sg`, `loc_pl` (locative)

**Adjectives — Additional Forms**:
- Prefix with `def_` or `indef_` for definite/indefinite: `def_nom_sg_m`, `indef_nom_sg_m`
- Suffix with gender: `_m`, `_f`, `_n`
- Comparative/superlative: `comp_nom_sg_m`, `super_nom_sg_m`

**Verbs (Tense + Person + Number)**:
- Present: `pres_1sg`, `pres_2sg`, `pres_3sg`, `pres_1pl`, `pres_2pl`, `pres_3pl`
- Past/Perfect: `past_m_sg`, `past_f_sg`, `past_n_sg`, `past_m_pl`, `past_f_pl`, `past_n_pl`
- Future: Often analytical (će + infinitive), but synthetic forms: `fut_1sg`, etc.
- Imperative: `imp_2sg`, `imp_1pl`, `imp_2pl`
- Infinitive: `inf` (this is also the root, so technically redundant but explicit)
- Present adverbial participle: `pres_adv_part`
- Past adverbial participle: `past_adv_part`
- Passive participle: `pass_part_m_sg`, etc.

**Other Parts of Speech**:
- Invariable words (adverbs, prepositions, conjunctions): `base` or `invariable`
- Numerals with forms: follow noun/adjective patterns as applicable

---

## 3. Grammar Metadata (JSONB) — Detailed Schema by Part of Speech

The `grammar_metadata` column stores exception data and rule engine configuration. Here are the expected keys for each part of speech.

### Nouns

```json
{
  "fleeting_a": true,           // Vowel disappears in declension: "pas" → "psa" (not "pasa")
  "palatalization": true,       // Consonant softening: "junak" → "junače" (vocative)
  "irregular_plural": "ljudi",  // Completely irregular plural form (for "čovek")
  "irregular_forms": {          // Any irregular declined forms
    "gen_pl": "očiju"           // Example: "oko" → "očiju" (not "oka")
  },
  "collective_noun": true,      // Grammatically singular but semantically plural
  "singularia_tantum": true,    // No plural form exists
  "pluralia_tantum": true       // No singular form exists (term stores plural)
}
```

### Verbs

```json
{
  "present_stem": "piš",        // When present stem differs from infinitive: "pisati" → "piš-em"
  "aorist_stem": "pisa",        // For aorist formation if different
  "irregular_forms": {          // Specific irregular conjugated forms
    "pres_1sg": "hoću",         // Example: "hteti" → "hoću" (not "htem")
    "pres_3pl": "hoće"
  },
  "defective": true,            // Missing some standard forms
  "impersonal": true,           // Used only in 3rd person (e.g., weather verbs)
  "auxiliary": true             // Marks auxiliary verbs (biti, hteti)
}
```

### Adjectives

```json
{
  "comparative_stem": "bolj",   // Irregular comparative: "dobar" → "bolji" (not "dobriji")
  "superlative_stem": "najbolji",
  "no_short_form": true,        // Lacks indefinite/short form
  "indeclinable": true,         // Foreign adjectives that don't decline: "bež", "fer"
  "irregular_forms": {
    "comp_nom_sg_m": "veći"     // Example: "velik" → "veći"
  }
}
```

### Pronouns

```json
{
  "manual_forms_only": true,    // Signal to rule engine: skip generation, trust seed cache entirely
  "pronoun_type": "personal",   // personal, demonstrative, possessive, interrogative, relative, reflexive, indefinite
  "clitic_forms": {             // Short/clitic forms
    "acc_sg": "ga",             // "njega" → "ga"
    "dat_sg": "mu"              // "njemu" → "mu"
  }
}
```

### Prepositions

```json
{
  "governs": "genitive",                    // Single case
  "governs": ["accusative", "locative"],    // Multiple cases with different meanings
  "notes": "acc = motion toward, loc = static location"
}
```

### Numerals

```json
{
  "numeral_type": "cardinal",   // cardinal, ordinal, collective
  "governs": "gen_sg",          // What case the counted noun takes: "dva psa" (gen sg)
  "gender_forms": true,         // Has gendered forms: "dva" (m), "dve" (f)
  "declines": true              // Whether the numeral itself declines
}
```

### Adverbs

```json
{
  "comparative": "bolje",       // Comparative form
  "superlative": "najbolje",    // Superlative form
  "derived_from": "dobar"       // Source adjective if derived
}
```

---

## 4. Ecto Schema — Word (Reference Implementation)

This is the complete Ecto schema for the `vocabulary_words` table. Use this as the implementation reference.

```elixir
defmodule App.Vocabulary.Word do
  use Ecto.Schema
  import Ecto.Changeset

  @parts_of_speech ~w(noun verb adjective adverb pronoun preposition conjunction interjection particle numeral)a
  @genders ~w(masculine feminine neuter)a
  @aspects ~w(perfective imperfective biaspectual)a

  # Parts of speech that require gender
  @gendered_pos ~w(noun adjective pronoun)a

  schema "vocabulary_words" do
    # Identity
    field :term, :string
    field :translation, :string
    field :translations, {:array, :string}, default: []
    field :part_of_speech, Ecto.Enum, values: @parts_of_speech
    field :proficiency_level, :integer, default: 1

    # Noun-specific
    field :gender, Ecto.Enum, values: @genders
    field :animate, :boolean
    field :declension_class, :string

    # Verb-specific
    field :verb_aspect, Ecto.Enum, values: @aspects
    field :conjugation_class, :string
    field :reflexive, :boolean, default: false
    field :transitive, :boolean

    # Relationships
    belongs_to :aspect_pair, __MODULE__
    has_many :search_terms, App.Search.SearchTerm

    # Flexible metadata
    field :grammar_metadata, :map, default: %{}

    # Content
    field :example_sentence_rs, :string
    field :example_sentence_en, :string
    field :audio_url, :string
    field :image_url, :string
    field :usage_notes, :string

    # Categorization
    field :categories, {:array, :string}, default: []

    timestamps(type: :utc_datetime)
  end

  @required_fields ~w(term translation part_of_speech)a
  @optional_fields ~w(
    translations proficiency_level gender animate declension_class
    verb_aspect conjugation_class reflexive transitive aspect_pair_id
    grammar_metadata example_sentence_rs example_sentence_en
    audio_url image_url usage_notes categories
  )a

  def changeset(word, attrs) do
    word
    |> cast(attrs, @required_fields ++ @optional_fields)
    |> validate_required(@required_fields)
    |> validate_number(:proficiency_level, greater_than: 0, less_than: 10)
    |> validate_gender_required()
    |> validate_animate_for_masculine_nouns()
    |> validate_verb_aspect_required()
    |> foreign_key_constraint(:aspect_pair_id)
  end

  # Gender is required for nouns, adjectives, and pronouns
  defp validate_gender_required(changeset) do
    pos = get_field(changeset, :part_of_speech)

    if pos in @gendered_pos do
      validate_required(changeset, [:gender])
    else
      changeset
    end
  end

  # Animate is required for masculine nouns (must be explicitly true or false)
  defp validate_animate_for_masculine_nouns(changeset) do
    pos = get_field(changeset, :part_of_speech)
    gender = get_field(changeset, :gender)

    if pos == :noun and gender == :masculine do
      validate_required(changeset, [:animate])
    else
      changeset
    end
  end

  # Verb aspect is required for verbs
  defp validate_verb_aspect_required(changeset) do
    pos = get_field(changeset, :part_of_speech)

    if pos == :verb do
      validate_required(changeset, [:verb_aspect])
    else
      changeset
    end
  end
end
```

---

## 5. Ecto Schema — SearchTerm (Specification)

Create an Ecto schema for the `search_terms` table with these requirements:

**Fields**:
- `term` (string, required) — the surface form, stored lowercase
- `form_tag` (string, required) — grammatical description, stored lowercase
- `word_id` (references vocabulary_words, required)
- `source` (enum: seed/manual/engine, required, default: seed)
- `locked` (boolean, required, default: false)
- timestamps

**Validations**:
- All fields except `locked` required
- `term` should be lowercased on cast (normalize input)
- `form_tag` should be lowercase (add validation or normalize on cast)

**Relationships**:
- `belongs_to :word, App.Vocabulary.Word`

**Indexes** (in migration):
- Index on `term`
- Unique index on `[:term, :word_id, :form_tag]`

---

## 6. Migration Specifications

### Migration 1: Create Enums

Create the four PostgreSQL enum types before the tables reference them.

```elixir
# Use execute/1 for raw SQL to create enums
execute("CREATE TYPE part_of_speech AS ENUM ('noun', 'verb', 'adjective', 'adverb', 'pronoun', 'preposition', 'conjunction', 'interjection', 'particle', 'numeral')")
execute("CREATE TYPE grammatical_gender AS ENUM ('masculine', 'feminine', 'neuter')")
execute("CREATE TYPE verb_aspect AS ENUM ('perfective', 'imperfective', 'biaspectual')")
execute("CREATE TYPE search_term_source AS ENUM ('seed', 'manual', 'engine')")
```

Include down migration to drop types in reverse order.

### Migration 2: Create vocabulary_words Table

Create table with all columns specified in Section 2.B. Key points:
- Use the enum types for `part_of_speech`, `gender`, `verb_aspect`
- `grammar_metadata` is `:map` type (becomes JSONB in Postgres)
- `categories` is `{:array, :string}`
- `aspect_pair_id` references self: `references(:vocabulary_words, on_delete: :nilify_all)`
- Include all indexes specified

### Migration 3: Create search_terms Table

Create table with columns specified in Section 2.C. Key points:
- `word_id` references vocabulary_words with `on_delete: :delete_all`
- `source` uses the `search_term_source` enum, default `seed`
- `locked` boolean, default `false`
- Unique index on `[:term, :word_id, :form_tag]`
- Regular index on `term`

---

## 7. Seeding Infrastructure

### Seed File Location
`priv/repo/seeds.exs`

### Parallelization Note

The JSON seed generation can be parallelized by part of speech. Each part of speech is linguistically independent:
- Noun declensions require no knowledge of verb conjugation
- Adjective forms don't affect pronoun forms
- Each is a self-contained linguistic domain

**Recommended approach**: Generate separate JSON files per POS (nouns.json, verbs.json, adjectives.json, closed_class.json), then merge into a single vocabulary_seed.json before seeding.

### Expected JSON Format

Create or accept a JSON file with this structure:

```json
[
  {
    "term": "pas",
    "translation": "dog",
    "translations": ["hound", "canine"],
    "part_of_speech": "noun",
    "proficiency_level": 1,
    "gender": "masculine",
    "animate": true,
    "declension_class": "consonant",
    "grammar_metadata": {
      "fleeting_a": true
    },
    "categories": ["animals", "pets"],
    "forms": [
      {"term": "pas", "form_tag": "nom_sg"},
      {"term": "psa", "form_tag": "gen_sg"},
      {"term": "psa", "form_tag": "acc_sg"},
      {"term": "psu", "form_tag": "dat_sg"},
      {"term": "psu", "form_tag": "loc_sg"},
      {"term": "psom", "form_tag": "ins_sg"},
      {"term": "pse", "form_tag": "voc_sg"},
      {"term": "psi", "form_tag": "nom_pl"},
      {"term": "pasa", "form_tag": "gen_pl"},
      {"term": "psima", "form_tag": "dat_pl"},
      {"term": "pse", "form_tag": "acc_pl"},
      {"term": "psi", "form_tag": "voc_pl"},
      {"term": "psima", "form_tag": "ins_pl"},
      {"term": "psima", "form_tag": "loc_pl"}
    ]
  },
  {
    "term": "pisati",
    "translation": "to write",
    "part_of_speech": "verb",
    "verb_aspect": "imperfective",
    "conjugation_class": "e-verb",
    "reflexive": false,
    "grammar_metadata": {
      "present_stem": "piš"
    },
    "aspect_pair_term": "napisati",
    "forms": [
      {"term": "pisati", "form_tag": "inf"},
      {"term": "pišem", "form_tag": "pres_1sg"},
      {"term": "pišeš", "form_tag": "pres_2sg"},
      {"term": "piše", "form_tag": "pres_3sg"},
      {"term": "pišemo", "form_tag": "pres_1pl"},
      {"term": "pišete", "form_tag": "pres_2pl"},
      {"term": "pišu", "form_tag": "pres_3pl"},
      {"term": "piši", "form_tag": "imp_2sg"},
      {"term": "pišimo", "form_tag": "imp_1pl"},
      {"term": "pišite", "form_tag": "imp_2pl"},
      {"term": "pisao", "form_tag": "past_m_sg"},
      {"term": "pisala", "form_tag": "past_f_sg"},
      {"term": "pisalo", "form_tag": "past_n_sg"},
      {"term": "pisali", "form_tag": "past_m_pl"},
      {"term": "pisale", "form_tag": "past_f_pl"},
      {"term": "pisala", "form_tag": "past_n_pl"}
    ]
  }
]
```

### Seed Logic

1. Read JSON file from configurable path (default: `priv/repo/vocabulary_seed.json`)
2. For each entry:
   a. Extract `forms` array and remove from attributes
   b. Extract `aspect_pair_term` if present (for later linking)
   c. Insert into `vocabulary_words`, get back the ID
   d. For each form in `forms` array:
      - Lowercase the `term` value
      - Insert into `search_terms` with `word_id`, `source: :seed`, `locked: false`
3. Second pass: Link aspect pairs by looking up `aspect_pair_term` and updating `aspect_pair_id`
4. Handle errors gracefully — log and continue, don't fail entire seed on one bad entry
5. Wrap in transaction for atomicity (or make idempotent with upserts)

### Idempotency Consideration

For development, support re-running seeds:
- Option A: Clear tables before seeding
- Option B: Use `ON CONFLICT DO UPDATE` (upsert) — requires deciding on conflict key
- Option C: Check existence before insert

Recommend Option A for simplicity in development phase.

---

## 8. Transliteration Utility

### Module Location
`lib/app/utils/transliteration.ex`

### Public API

```elixir
# Latin to Cyrillic (primary use: display)
App.Utils.Transliteration.to_cyrillic("Dobro jutro")
# => "Добро јутро"

App.Utils.Transliteration.to_cyrillic("Ljubav")
# => "Љубав"

# Cyrillic to Latin (required for search input normalization)
App.Utils.Transliteration.to_latin("Добро јутро")
# => "Dobro jutro"

App.Utils.Transliteration.to_latin("пса")
# => "psa"
```

### Implementation Requirements

**Digraph Handling (Critical)**

Serbian has digraphs that map to single Cyrillic letters. These must be processed BEFORE single characters:

| Latin | Cyrillic | Note |
|-------|----------|------|
| Lj, lj | Љ, љ | Must match before L+j separately |
| Nj, nj | Њ, њ | Must match before N+j separately |
| Dž, dž | Џ, џ | Must match before D+ž separately |

**Full Mapping Table**

| Latin | Cyrillic | | Latin | Cyrillic |
|-------|----------|---|-------|----------|
| A, a | А, а | | N, n | Н, н |
| B, b | Б, б | | Nj, nj | Њ, њ |
| C, c | Ц, ц | | O, o | О, о |
| Č, č | Ч, ч | | P, p | П, п |
| Ć, ć | Ћ, ћ | | R, r | Р, р |
| D, d | Д, д | | S, s | С, с |
| Dž, dž | Џ, џ | | Š, š | Ш, ш |
| Đ, đ | Ђ, ђ | | T, t | Т, т |
| E, e | Е, е | | U, u | У, у |
| F, f | Ф, ф | | V, v | В, в |
| G, g | Г, г | | Z, z | З, з |
| H, h | Х, х | | Ž, ž | Ж, ж |
| I, i | И, и | | | |
| J, j | Ј, ј | | | |
| K, k | К, к | | | |
| L, l | Л, л | | | |
| Lj, lj | Љ, љ | | | |
| M, m | М, м | | | |

**Algorithm for to_cyrillic/1**:
1. Process string left to right
2. At each position, check for digraph match first (2 characters)
3. If no digraph, convert single character
4. Preserve characters not in mapping (punctuation, numbers, spaces)
5. Handle case preservation (uppercase input → uppercase output)

**Algorithm for to_latin/1**:
1. Simpler: each Cyrillic character maps to exactly one Latin character/digraph
2. Direct character-by-character replacement
3. Handle case preservation

**Edge Cases**:
- "LJUBAV" (all caps) → "ЉУБАВ" → "LJUBAV"
- "nj" vs "n" + "j" in compound words — in standard Serbian orthography, this ambiguity doesn't exist in native words, but loanwords might have it. For v1, treat all "nj" sequences as the digraph.

---

## 9. Search Logic

### Module Location
`lib/app/search.ex` or `lib/app/search/search.ex`

### Public API

```elixir
App.Search.lookup("psa")
# => [
#   %{
#     word: %App.Vocabulary.Word{term: "pas", translation: "dog", ...},
#     matched_form: "psa",
#     form_tag: "gen_sg"
#   }
# ]

# Cyrillic input works transparently
App.Search.lookup("пса")
# => [same result as above]

App.Search.lookup("sam")
# => [
#   %{word: %Word{term: "biti", ...}, matched_form: "sam", form_tag: "pres_1sg"},
#   %{word: %Word{term: "sam", ...}, matched_form: "sam", form_tag: "nom_sg_m"}
# ]
# (homograph example: "sam" = "I am" or "alone")
```

### Implementation Requirements

1. **Input Normalization** (Critical):
   a. Convert Cyrillic to Latin using `Transliteration.to_latin/1`
   b. Lowercase the result
   c. This normalized string is used for the database query

2. **Query**: Search `search_terms` table for exact match on `term`

3. **Preload**: Join/preload the associated `vocabulary_words` record

4. **Return structure**: List of maps with `:word`, `:matched_form`, `:form_tag` keys

5. **Empty results**: Return empty list `[]`, not nil or error

6. **Performance**: The index on `search_terms.term` should make this fast

### Normalization Flow

```
User Input: "ПСА" (Cyrillic, uppercase)
     ↓ to_latin/1
     "PSA" (Latin, uppercase)
     ↓ String.downcase/1
     "psa" (Latin, lowercase)
     ↓ Database query
     Match found in search_terms
```

### Future Enhancement: Fuzzy Search

Not required for Sprint 1, but consider architecture that allows adding:
- Prefix matching ("ps" finds "pas", "psa", "psima")
- Levenshtein distance for typo tolerance

---

## 10. Flashcard UI (LiveView)

### Route
`/flashcards` or `/practice`

### Core Features

1. **Random Word Selection**: Fetch a random word from `vocabulary_words` at appropriate proficiency level

2. **Card Display**:
   - Front: Serbian word (term) with part of speech badge
   - Back: English translation, example sentence (if available)

3. **Flip Interaction**: Click/tap to flip card, reveal answer

4. **Script Toggle**: Button to switch display between Latin and Cyrillic (use Transliteration utility)

5. **Linguistic Badges**: Visual indicators for:
   - Gender (color-coded): M = blue, F = red/pink, N = green/gray
   - Verb aspect: PF (perfective), IPF (imperfective), BI (biaspectual)
   - Animate/Inanimate for masculine nouns (optional, could be icon)

6. **Navigation**: Next card button, possibly previous

### LiveView Implementation Notes

- Use `assigns` to track: current word, flipped state, script mode (latin/cyrillic)
- `handle_event` for: flip, next, toggle_script
- Consider keyboard shortcuts: Space to flip, Arrow keys for navigation
- `ORDER BY RANDOM()` is acceptable for MVP scale (<10k words); note this doesn't scale

### Stretch Goals (Post-Sprint 1)

- Show all declined/conjugated forms on back of card
- Audio playback button
- Track seen/unseen, implement spaced repetition
- Filter by category
- Filter by proficiency level

---

## 11. Context Module Organization

### Recommended Structure

```
lib/app/
├── vocabulary/
│   ├── vocabulary.ex      # Context module: public API for vocabulary operations
│   └── word.ex            # Ecto schema
├── search/
│   ├── search.ex          # Context module: lookup function
│   └── search_term.ex     # Ecto schema
├── utils/
│   └── transliteration.ex # Latin ↔ Cyrillic conversion
└── linguistics/           # Future: Rule engine
    └── (empty for now)
```

### Vocabulary Context API

```elixir
App.Vocabulary.list_words(opts \\ [])           # List with filters
App.Vocabulary.get_word!(id)                     # Fetch by ID
App.Vocabulary.get_random_word(opts \\ [])       # For flashcards
App.Vocabulary.create_word(attrs)                # Create with validation
App.Vocabulary.update_word(word, attrs)          # Update
App.Vocabulary.delete_word(word)                 # Delete (cascades to search_terms)
```

---

## 12. Testing Strategy

### Schema Tests

- Valid changeset with all required fields
- Invalid changeset: noun without gender
- Invalid changeset: masculine noun without animate
- Invalid changeset: verb without aspect
- Valid optional fields (translations array, categories array)
- grammar_metadata accepts arbitrary maps

### Search Tests

- Exact match returns correct word
- Homograph returns multiple results
- No match returns empty list
- Case insensitivity works (uppercase input finds lowercase data)
- **Cyrillic input works** (transliterated and matched)

### Transliteration Tests

- Basic characters convert correctly (both directions)
- Digraphs (Lj, Nj, Dž) convert correctly (both directions)
- Mixed case preserves case
- Non-Serbian characters pass through unchanged
- Empty string returns empty string
- **Round-trip**: `to_cyrillic(to_latin(cyrillic)) == cyrillic`

### Seed Tests

- Valid JSON imports correctly
- Word count matches expected
- Search terms created for each form
- Search terms are lowercase
- Search terms have `source: :seed` and `locked: false`
- Aspect pairs linked correctly

---

## 13. Open Questions / Decisions Needed

1. **App Name**: Replace `App` placeholder with actual module prefix

2. **Sense Index for Homographs**: Add `sense_index` integer field now, or defer until needed?

3. **Proficiency Levels**: Finalize the scale (1-5? 1-10?) and what each level means

4. **Category Taxonomy**: Define initial set of categories, or leave freeform?

5. **Audio/Image Storage**: Local files, S3, or external URLs? (Affects seeding)

6. **Seed File Location**: Hardcoded path or configurable?

---

## 14. Sprint 1 Backlog Summary

| ID | Task | Depends On |
|----|------|------------|
| PBI-001 | Create migration for enums (including search_term_source) | — |
| PBI-002 | Create migration for vocabulary_words | PBI-001 |
| PBI-003 | Create migration for search_terms (with source, locked) | PBI-001, PBI-002 |
| PBI-004 | Implement Word Ecto schema with validations | PBI-002 |
| PBI-005 | Implement SearchTerm Ecto schema | PBI-003 |
| PBI-006 | Implement Transliteration utility (both directions) | — |
| PBI-007 | Implement Search.lookup/1 with input normalization | PBI-005, PBI-006 |
| PBI-008 | Create seed infrastructure | PBI-004, PBI-005 |
| PBI-009 | Generate initial vocabulary JSON (AI task, parallelizable by POS) | — |
| PBI-010 | Implement Flashcard LiveView | PBI-004, PBI-006, PBI-007 |

---

## 15. Known Limitations (Sprint 1)

These are intentional scope limitations for Sprint 1. Document them to prevent scope creep and set expectations.

### Compound Tense Search

Serbian compound tenses split across multiple words:
- "smejati se" (to laugh) → past tense: "smejao sam se" or "ja sam se smejao"
- Future: "smejaću se" or "ja ću se smejati"

**Current behavior**: Searching "smejao sam se" will NOT match. User must search for individual components:
- "smejao" → finds the participle, links to "smejati se"
- "smejati" → finds the infinitive

**Future solution**: Requires the rule engine + query decomposition logic.

### Pitch Accent

Serbian has 4 tonal accent patterns. These are:
- Not marked in standard written Serbian
- Important for pronunciation but not meaning (usually)
- Best handled by audio files rather than diacritical markup

**Current behavior**: No accent information stored or displayed.

**Future solution**: Add `stress_position` field and/or rely on audio_url for pronunciation.

### Multi-Word Expressions

Idioms, phrasal verbs, and multi-word prepositions (e.g., "zbog toga što") are not fully supported.

**Current behavior**: Can be stored as single entries in vocabulary_words, but search won't find partial matches.

### No Spaced Repetition

Flashcards are purely random. No tracking of what the user knows.

**Future solution**: Add user progress tracking, implement SM-2 or similar algorithm.

---

## 16. Future Architecture — Rule Engine

This section documents the target architecture for the rule engine that will eventually replace the JSON seed approach. Not for Sprint 1 implementation, but informs current design decisions.

### Core Concept: Inflector Behaviour

Define a behaviour (interface) that all part-of-speech rule modules implement:

```elixir
defmodule App.Linguistics.Inflector do
  @doc "Returns true if this inflector handles the given word"
  @callback applicable?(word :: App.Vocabulary.Word.t()) :: boolean()

  @doc "Generates all inflected forms for the word"
  @callback generate_forms(word :: App.Vocabulary.Word.t()) :: [
    {term :: String.t(), form_tag :: String.t()}
  ]
end
```

### Module Structure

```
lib/app/linguistics/
├── inflector.ex           # Behaviour definition
├── dispatcher.ex          # Routes words to correct inflector
├── nouns.ex               # Implements Inflector for nouns
├── verbs.ex               # Implements Inflector for verbs
├── adjectives.ex          # Implements Inflector for adjectives
├── pronouns.ex            # Implements Inflector for pronouns
└── invariables.ex         # Handles adverbs, prepositions, conjunctions, etc.
```

### Why This Design Parallelizes

- **Shared interface**: All inflectors have identical function signatures
- **No cross-dependencies**: Noun rules never call verb rules
- **Isolated testing**: Each module has independent test suite
- **Independent metadata**: Each reads only its relevant `grammar_metadata` keys

### Phased Implementation

**Phase 1 (Sequential — One person/agent)**:
- Define Inflector behaviour
- Create dispatcher skeleton
- Set up test structure with fixtures

**Phase 2 (Parallel — Multiple agents)**:
- Agent A: Noun declension rules + tests
- Agent B: Verb conjugation rules + tests
- Agent C: Adjective inflection rules + tests
- Agent D: Pronouns, numerals, invariables + tests

**Phase 3 (Sequential — Integration)**:
- Wire dispatcher to use all inflectors
- Integration testing
- Cache regeneration logic (respecting `locked` flags)

### Cache Regeneration Flow

When the rule engine is ready:

1. BEGIN TRANSACTION
2. DELETE FROM search_terms WHERE locked = false
3. FOR each word in vocabulary_words:
   a. Find applicable inflector
   b. Generate forms
   c. INSERT INTO search_terms with source = 'engine'
4. COMMIT

Manual corrections (locked = true) are preserved throughout.

---

## Appendix A: Sample Vocabulary Entries for Testing

Include at least these patterns in initial seed for comprehensive testing:

| Word | Why Include |
|------|-------------|
| pas (dog) | Masculine animate, fleeting-a, common |
| sto (table) | Masculine inanimate |
| žena (woman) | Feminine a-stem, animate |
| selo (village) | Neuter o-stem |
| dete (child) | Neuter irregular (plural: deca) |
| pisati/napisati | Verb aspect pair, stem change |
| biti (to be) | Highly irregular auxiliary |
| ja (I) | Pronoun with clitic forms |
| dobar (good) | Adjective with irregular comparative |
| dva (two) | Numeral with gender forms |
| u (in) | Preposition governing multiple cases |
| i (and) | Invariable conjunction |
| brzo (quickly) | Adverb with comparative |

---

*End of Master Prompt v2*
