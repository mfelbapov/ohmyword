# Design Decisions

Key architectural and design decisions made during development, with rationale.

---

## Data Architecture

### Dual-form storage (term + display_form)

**Decision**: The `search_terms` table stores each form twice: `term` (ASCII, diacritics stripped) for matching, and `display_form` (with diacritics) for display.

**Why**: Serbian has diacritical characters (c, c, s, z, dj) that users may not be able to type. Stripping diacritics for search means "cas" matches "cas" (honor), but we still display the correct form. This also normalizes Cyrillic input (converted to Latin, then stripped).

**Where stripping happens**: Only at storage time in CacheManager and seed loader, via `Utils.Transliteration.strip_diacritics/1`. The Dispatcher and inflectors always produce diacritical forms.

### Two-table architecture (vocabulary_words + search_terms)

**Decision**: Separate the dictionary entry (source of truth) from the searchable forms (cache).

**Why**: A noun like "pas" (dog) has 14 inflected forms. Storing them flat in a search table means fast lookups without joins. The source word retains linguistic structure (gender, animacy, metadata). The cache can be regenerated from the engine at any time.

### Unified sentence bank (sentences + sentence_words)

**Decision**: Replaced per-word `example_sentence_rs/en` fields with a shared `sentences` table and `sentence_words` join table.

**Why**: One sentence often demonstrates multiple words. The old per-word approach duplicated sentences and couldn't support multi-blank exercises. The join table allows any word in a sentence to become a blank, enabling difficulty levels (1 blank, half, all).

---

## Linguistics Engine

### Irregular forms via metadata (not code)

**Decision**: Irregular word forms are stored as `grammar_metadata.irregular_forms` (a map of form_tag -> form_string) in the seed data, not hardcoded per-word in engine code.

**Why**: Patterns belong in engine code (e.g., "all consonant-stem masculine nouns get -ov- plural insert"). But one-off irregularities belong in data. This keeps the engine clean and makes it easy to add exceptions without code changes.

### Diacritics preserved in engine output

**Decision**: The Dispatcher and all inflectors produce forms with full Serbian Latin diacritics. Stripping to ASCII happens only at the CacheManager/storage layer.

**Why**: Initially the Dispatcher stripped diacritics, but this made `display_form` impossible to populate correctly. Moving stripping to the storage layer means the engine output is the "true" linguistic form, and downstream consumers decide how to use it.

### Tag naming conventions

**Decision**: Standardized form tags across all POS:
- Invariables use `"invariable"` (not `"base"`)
- Adverb comparison uses `"comparative"` / `"superlative"`
- Pronouns use `_sg` / `_pl` suffixes
- Adjectives: `indef_nom_sg_m`, `def_gen_pl_f`, `comp_ins_sg_n`, etc.
- Nouns: `nom_sg`, `gen_pl`, etc.
- Verbs: `pres_1sg`, `past_m_sg`, `imp_2pl`, `pass_part_f_pl`, `pres_adv_part`, `past_adv_part`

**Why**: Consistent tags make answer checking and inflection table rendering predictable. The tag encodes enough information (definiteness, case, number, gender) to be self-describing.

### Soft-stem detection for adjectives and ordinal numerals

**Decision**: Soft-stem adjectives (ending in c, c, s, z, dj, j, lj, nj, dz) use different definite endings: `-eg/-em` instead of `-og/-om` for m/n gen/dat/loc singular.

**Why**: This is a real grammatical distinction in Serbian. Hardcoding it prevents systematic errors across all soft-stem adjectives and ordinal numerals.

### Verb passive participle handling

**Decision**: Passive participles are generated by default but can be suppressed with `no_passive_participle` metadata flag.

**Why**: Many verbs (intransitive, modal, reflexive) don't have passive participles. Rather than trying to detect these automatically, the flag in seed data is explicit and correct.

---

## UI & Features

### Script toggle (Latin/Cyrillic)

**Decision**: All data stored in Latin. Cyrillic rendered dynamically via `Utils.Transliteration.to_cyrillic/1`. Users toggle between scripts in the UI.

**Why**: Storing both scripts would double the data. Serbian Latin and Cyrillic have a 1:1 mapping (with digraph handling for Lj/Nj/Dz), so transliteration is lossless and fast.

### Multi-blank sentence exercises with difficulty levels

**Decision**: Three difficulty levels: 1 = one blank (with hints), 2 = one blank (no hints), 3 = all annotated words blanked.

**Why**: Progressive difficulty. Level 1 is for beginners who need context clues. Level 3 tests full sentence production. The annotated words in `sentence_words` define which positions can become blanks.

### Diacritic-insensitive answer checking

**Decision**: When checking user answers, both the input and expected forms are normalized (to_latin -> strip_diacritics -> downcase) before comparison.

**Why**: Users may not have a Serbian keyboard. Accepting "cas" for "cas" reduces frustration while still teaching correct forms (the display always shows diacritics).

### Public exercise routes (no auth required)

**Decision**: Dictionary, flashcards, word detail, and sentence exercises are all publicly accessible without login.

**Why**: The primary user is learning, not managing data. Requiring login for practice would add friction. Auth protects admin features and user settings only.

---

## Infrastructure

### Tag-based deployment (not merge-based)

**Decision**: Merging to main does NOT deploy. Only pushing a version tag (`v*`) triggers production deployment.

**Why**: Separates "code is ready" from "we want to deploy." Multiple PRs can merge before a deliberate deployment. Prevents accidental deployments from routine merges.

### Always run `mix precommit` before commits

**Decision**: A custom `mix precommit` task runs: compile (warnings-as-errors), deps.unlock (unused), format check, and full test suite.

**Why**: CI runs the same checks. Running locally first catches issues before push, avoiding wasted CI cycles and broken builds.

### Bandit over Cowboy

**Decision**: Use Bandit as the HTTP server instead of Cowboy.

**Why**: Phoenix 1.8+ default. Pure Elixir implementation, simpler configuration, good performance for LiveView workloads.
